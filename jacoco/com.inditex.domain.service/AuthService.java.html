<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AuthService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">test</a> &gt; <a href="index.source.html" class="el_package">com.inditex.domain.service</a> &gt; <span class="el_source">AuthService.java</span></div><h1>AuthService.java</h1><pre class="source lang-java linenums">package com.inditex.domain.service;

import com.inditex.domain.port.in.AuthServicePort;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;

import javax.crypto.Cipher;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

/**
 * Servicio encargado de la validación de credenciales utilizando un sistema de encriptación RSA.
 * Este servicio utiliza una clave privada para desencriptar las credenciales almacenadas (usuario y contraseña)
 * y compararlas con los valores proporcionados durante el proceso de autenticación.
 *
 * &lt;p&gt;Este servicio implementa la interfaz {@link AuthServicePort}, lo que permite su integración con el resto
 * de la aplicación.&lt;/p&gt;
 */
@Primary
@Service
<span class="fc" id="L28">@Slf4j  // Anotación de Lombok para habilitar logging en la clase.</span>
<span class="fc" id="L29">public class AuthService implements AuthServicePort {</span>

    // Propiedades inyectadas desde el archivo de configuración, conteniendo las credenciales encriptadas
    @Value(&quot;${jwt.user}&quot;)
    private String jwtUser;

    @Value(&quot;${jwt.password}&quot;)
    private String jwtPassword;

    /**
     * Valida las credenciales de un usuario comparando los valores proporcionados con los valores desencriptados
     * almacenados en las propiedades configuradas (jwt.user y jwt.password).
     *
     * @param user      El nombre de usuario proporcionado para la autenticación.
     * @param contrasena La contraseña proporcionada para la autenticación.
     * @return {@code true} si las credenciales proporcionadas coinciden con las credenciales desencriptadas,
     *         {@code false} si no coinciden o si ocurre algún error durante el proceso.
     */
    @Override
    public boolean validateCredentials(String user, String contrasena) {
        try {
<span class="fc" id="L50">            log.info(&quot;Iniciando validación de credenciales para el usuario: {}&quot;, user);</span>

            // Cargar clave privada desde resources
<span class="fc" id="L53">            byte[] privateKeyBytes = Files.readAllBytes(Paths.get(&quot;src/main/resources/key/private_key.pem&quot;));</span>
<span class="fc" id="L54">            PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);</span>
<span class="fc" id="L55">            KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);</span>
<span class="fc" id="L56">            PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span>
<span class="fc" id="L57">            log.debug(&quot;Clave privada cargada correctamente.&quot;);</span>

            // Desencriptar jwt.user utilizando la clave privada
<span class="fc" id="L60">            String decryptedUser = decryptWithPrivateKey(jwtUser, privateKey);</span>
<span class="fc" id="L61">            log.debug(&quot;Usuario desencriptado: {}&quot;, decryptedUser);</span>

            // Desencriptar jwt.password utilizando la clave privada
<span class="fc" id="L64">            String decryptedPassword = decryptWithPrivateKey(jwtPassword, privateKey);</span>
<span class="fc" id="L65">            log.debug(&quot;Contraseña desencriptada: {}&quot;, decryptedPassword);</span>

            // Comparar las credenciales desencriptadas con las proporcionadas
<span class="fc bfc" id="L68" title="All 4 branches covered.">            boolean credentialsValid = user.equals(decryptedUser) &amp;&amp; contrasena.equals(decryptedPassword);</span>
<span class="fc" id="L69">            log.info(&quot;Credenciales validadas: {}&quot;, credentialsValid);</span>

<span class="fc" id="L71">            return credentialsValid;</span>
<span class="fc" id="L72">        } catch (Exception e) {</span>
            // Imprimir error y retornar false si ocurre una excepción durante la validación
<span class="fc" id="L74">            log.error(&quot;Error durante la validación de credenciales: {}&quot;, e.getMessage(), e);</span>
<span class="fc" id="L75">            return false;</span>
        }
    }

    /**
     * Desencripta un dato encriptado utilizando la clave privada proporcionada.
     *
     * @param encryptedData El dato encriptado que se desea desencriptar (en formato Base64).
     * @param privateKey    La clave privada utilizada para desencriptar el dato.
     * @return El dato desencriptado como una cadena de texto.
     * @throws Exception Si ocurre un error durante el proceso de desencriptado.
     */
    private String decryptWithPrivateKey(String encryptedData, PrivateKey privateKey) throws Exception {
<span class="fc" id="L88">        log.debug(&quot;Iniciando desencriptación de los datos.&quot;);</span>

        // Inicializar el objeto Cipher para desencriptar con RSA
<span class="fc" id="L91">        Cipher cipher = Cipher.getInstance(&quot;RSA&quot;);</span>
<span class="fc" id="L92">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span>

        // Decodificar el dato encriptado desde Base64
<span class="fc" id="L95">        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedData);</span>

        // Desencriptar el dato
<span class="fc" id="L98">        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);</span>

        // Convertir el dato desencriptado a String y retornarlo
<span class="fc" id="L101">        String decryptedString = new String(decryptedBytes, StandardCharsets.UTF_8);</span>
<span class="fc" id="L102">        log.debug(&quot;Datos desencriptados exitosamente: {}&quot;, decryptedString);</span>

<span class="fc" id="L104">        return decryptedString;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>